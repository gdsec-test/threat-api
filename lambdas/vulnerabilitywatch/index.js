const AWS = require('aws-sdk');
const {
  DynamoDBClient,
  BatchWriteItemCommand
} = require('@aws-sdk/client-dynamodb');
const { TABLE_DEFINITION, TABLE_NAME } = require('./const');

// strange way to support CommonJS in node-fetch https://github.com/node-fetch/node-fetch#commonjs
const fetch = (...args) =>
  import('node-fetch').then(({ default: fetch }) => fetch(...args));

// Handler
async function handler(event, context) {
  const region = process.env.AWS_REGION || 'us-west-2';
  const ok = await createCVETableIfNotExist({ region });
  if (!ok) {
    return Promise.resolve(false);
  }
  const {
    apiKey,
    endpoint,
    periodDays,
    resultsPerPage,
    throttleTimeout,
    slackWebhook
  } = await getNVDParams({ region });
  const freshCVEs = await getFreshCVEs({
    apiKey,
    endpoint,
    periodDays,
    resultsPerPage,
    throttleTimeout,
    slackWebhook
  });
  var dynamodb = new AWS.DynamoDB({ region, maxRetries: 3, sslEnabled: true });
  const CVEsFromDB = await getCVEsFromDB({ dynamodb });
  const updatedCVEs = [];
  const newCVEs = [];
  for (var [ID, freshCVE] of freshCVEs) {
    const newScore = getCVEScore(freshCVE);
    if (CVEsFromDB.has(ID)) {
      // DB contains existing CVE
      const dbCVEScore = CVEsFromDB.get(ID);
      if (dbCVEScore.toString() !== newScore.toString()) {
        // shoot slack message and update CVE
        updatedCVEs.push({ ID, oldScore: dbCVEScore, newScore });
        saveCVE({ item: freshCVE, dynamodb }); // CVE is present, but it needs to be updated in DB
      }
    } else {
      newCVEs.push({ ID, score: newScore });
      saveCVE({ item: freshCVE, dynamodb }); // CVE is new and needs to be saved in DB
    }
  }
  if (updatedCVEs.length || newCVEs.length) {
    fetch(slackWebhook, {
      method: 'post',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        text:
          `The next CVEs have changed their score in last ${periodDays} days\n` +
          updatedCVEs
            .map(
              ({ ID, oldScore, newScore }) =>
                `CVE: ${ID}: from ${oldScore} to ${newScore}`
            )
            .join('\n') +
          `\nThe next CVEs are new in last ${periodDays} days\n` +
          newCVEs.map(({ ID, score }) => `CVE: ${ID}: ${score}`).join('\n')
      })
    })
      .then((data) => {
        console.log('Alarm sent to Slack', data);
      })
      .catch((err) => {
        console.log('Could not send alarm to Slack', err);
      });
  }
  return Promise.resolve();
}

async function getCVEsFromDB({ dynamodb }) {
  const query = {
    TableName: TABLE_NAME,
    ProjectionExpression: 'cve_id,score'
  };
  let dbCVEs = new Map();
  let LastEvaluatedKey, err;
  do {
    const result = await new Promise((resolve) => {
      const currentQuery = LastEvaluatedKey
        ? { ...query, ExclusiveStartKey: LastEvaluatedKey }
        : query;
      dynamodb.scan(currentQuery, function(err, data) {
        if (err) {
          console.log(err, err.stack);
          resolve({ err });
        } else {
          const { LastEvaluatedKey, Items = [], Count } = data;
          resolve({ LastEvaluatedKey, Items, Count });
        }
      });
    });
    LastEvaluatedKey = result.LastEvaluatedKey;
    err = result.err;

    const currentCVEs = new Map(
      Object.entries(
        result.Items.reduce((acc, item) => {
          const { cve_id: { S: ID } = {}, score: { N: score } = {} } = item;
          acc[ID] = score;
          return acc;
        }, {})
      )
    );
    dbCVEs = new Map([...dbCVEs, ...currentCVEs]);
  } while (LastEvaluatedKey && !err);
  return Promise.resolve(dbCVEs);
}

async function saveCVE({ item, dynamodb }) {
  const { cve = {}, impact = {}, publishedDate, lastModifiedDate } = item;
  const {
    CVE_data_meta: { ID }
  } = cve;
  const {
    baseMetricV3: { cvssV3: { baseSeverity } = {} } = {},
    baseMetricV2: { cvssV2: { baseSeverity: baseSeverity2 } = {} } = {}
  } = impact;

  var params = {
    Item: {
      cve_id: {
        S: ID
      },
      score: {
        N: '' + getCVEScore(item)
      },
      severity: {
        S: '' + (baseSeverity || baseSeverity2 || '')
      },
      publishedDate: {
        S: publishedDate
      },
      lastModifiedDate: {
        S: lastModifiedDate
      },
      report: {
        B: Buffer.from(JSON.stringify(item), 'base64').toString('utf8')
      }
    },
    ReturnConsumedCapacity: 'TOTAL',
    TableName: TABLE_NAME
  };
  return new Promise((resolve) => {
    dynamodb.putItem(params, function (err, data) {
      if (err) {
        console.log(err, err.stack);
      } else {
        console.log('Successsfully saved CVE:' + ID);
      }
      resolve({ err, data });
    });
  });
}

async function getFreshCVEs({
  apiKey,
  endpoint,
  periodDays,
  resultsPerPage,
  throttleTimeout
}) {
  const formatDate = (date) =>
    date.toISOString().replace(/(:\d{2})(\.)(\d{3,})(Z)/gm, '$1:$3 UTC');
  const end = new Date();
  let start = new Date();
  start.setDate(end.getDate() - periodDays);
  let startIndex = 0;
  let totalResults = Number.POSITIVE_INFINITY;
  let CVEList = new Map();
  do {
    const URL = `${endpoint}?apiKey=${apiKey}&resultsPerPage=${resultsPerPage}&modStartDate=${formatDate(
      start
    )}&modEndDate=${formatDate(end)}&startIndex=${startIndex}`;
    let isError = false;
    const responseData = await fetch(URL)
      .catch((error) => {
        isError = error;
      })
      .then((response = {}) => {
        const url = URL;
        const {
          ok,
          status = 'Unknown',
          statusText = 'Request failed'
        } = response;
        if (!ok) {
          isError = new Error(status + statusText);
        }
        return response.json ? response.json() : { ok, status, statusText };
      });
    if (isError) {
      console.log(isError);
      break;
    }
    totalResults = responseData.totalResults || 0;
    const { result: { CVE_Items = [] } = {} } = responseData;
    const currentCVEList = new Map(
      Object.entries(
        CVE_Items.reduce((acc, item) => {
          const { cve: { CVE_data_meta: { ID } } = {} } = item;
          acc[ID] = item;
          return acc;
        }, {})
      )
    );
    CVEList = new Map([...CVEList, ...currentCVEList]);
    startIndex += parseInt(resultsPerPage);
    if (startIndex < totalResults) {
      // adding throttle timeouts to avoid rejected requests
      await new Promise((resolve) =>
        setTimeout(() => resolve(), parseInt(throttleTimeout))
      );
    }
  } while (startIndex < totalResults);
  return CVEList;
}

async function getNVDParams({ region }) {
  const secretName = '/ThreatTools/Integrations/nvd';
  const client = new AWS.SecretsManager({
    region
  });
  return new Promise((resolve) => {
    client.getSecretValue({ SecretId: secretName }, function (err, data) {
      if (err) {
        if (err.code === 'DecryptionFailureException') {
          throw err;
        } else if (err.code === 'InternalServiceErrorException') {
          throw err;
        } else if (err.code === 'InvalidParameterException') {
          throw err;
        } else if (err.code === 'InvalidRequestException') {
          throw err;
        } else if (err.code === 'ResourceNotFoundException') {
          throw err;
        }
        resolve(err);
      } else {
        if ('SecretString' in data) {
          resolve(JSON.parse(data.SecretString));
        } else {
          let buff = new Buffer(data.SecretBinary, 'base64');
          resolve(buff.toString('ascii'));
        }
      }
    });
  });
}

function getCVEScore(item = {}) {
  const { impact = {} } = item;
  const {
    baseMetricV3: { cvssV3: { baseScore = 0 } = {} } = {},
    baseMetricV2: { cvssV2: { baseScore: baseScore2 = 0 } = {} } = {}
  } = impact;
  return baseScore || baseScore2 || 0;
}
async function createCVETableIfNotExist({ region }) {
  var dynamodb = new AWS.DynamoDB({ region, maxRetries: 3, sslEnabled: true });
  const tableNotExist = await new Promise((resolve) => {
    dynamodb.describeTable(
      {
        TableName: TABLE_NAME
      },
      function (err = {}, data) {
        if (err) {
          if (err.code === 'ResourceNotFoundException') {
            // table does not exist
            resolve(true);
          } else {
            console.log('Unable to create table', JSON.stringify(err));
          }
        } else {
          resolve(false);
        }
      }
    );
  });
  return new Promise((resolve) => {
    if (tableNotExist) {
      dynamodb.createTable(TABLE_DEFINITION, function (err, data) {
        if (err) {
          console.log('Unable to create table', JSON.stringify(err));
          resolve(false);
        } else {
          resolve(true);
        }
      });
    } else {
      resolve(true);
    }
  });
}

// async function getAccountId () {
//   const sts = new AWS.STS();
//   const { Account: account } = await sts.getCallerIdentity({}).promise();
//   return account;
// }
exports.handler = handler;

handler();
