const AWS = require('aws-sdk');
const {
  DynamoDBClient,
  BatchWriteItemCommand
} = require('@aws-sdk/client-dynamodb');
const { TABLE_DEFINITION, TABLE_NAME } = require('./const');

// strange way to support CommonJS in node-fetch https://github.com/node-fetch/node-fetch#commonjs
const fetch = (...args) =>
  import('node-fetch').then(({ default: fetch }) => fetch(...args));

// Handler
async function handler(event, context) {
  const region = process.env.AWS_REGION || 'us-west-2';
  const ok = await createCVETableIfNotExist({ region });
  if (!ok) {
    return Promise.resolve(false);
  }
  const result = await getFreshCVEs(await getNVDParams({ region }));
  var dynamodb = new AWS.DynamoDB({ region, maxRetries: 3, sslEnabled: true });
  const newCVEs = result.map((item) => {
    const { cve = {}, impact = {}, publishedDate, lastModifiedDate } = item;
    const {
      CVE_data_meta: { ID }
    } = cve;
    const {
      baseMetricV3: { cvssV3: { baseScore = 0, baseSeverity } = {} } = {},
      baseMetricV2: {
        cvssV2: { baseScore: baseScore2 = 0, baseSeverity: baseSeverity2 } = {}
      } = {}
    } = impact;

    var params = {
      Item: {
        cve_id: {
          S: ID
        },
        score: {
          N: '' + (baseScore || baseScore2 || 0)
        },
        severity: {
          S: '' + (baseSeverity || baseSeverity2 || '')
        },
        publishedDate: {
          S: publishedDate
        },
        lastModifiedDate: {
          S: lastModifiedDate
        },
        report: {
          B: Buffer.from(JSON.stringify(item), 'base64').toString('utf8')
        }
      },
      ReturnConsumedCapacity: 'TOTAL',
      TableName: TABLE_NAME
    };
    dynamodb.putItem(params, function(err, data) {
      if (err) {
        console.log(err, err.stack);
      } else {
        console.log('Successsfully saved CVE:' + ID);
        console.log(data);
      }
    });

    return {
      PutRequest: {
        Item: {
          cve_id: {
            S: ID
          },
          score: {
            N: '' + (baseScore || baseScore2)
          },
          severity: {
            S: '' + (baseSeverity || baseSeverity2)
          },
          publishedDate: {
            S: publishedDate
          },
          lastModifiedDate: {
            S: lastModifiedDate
          },
          report: {
            M: item
          }
        }
      }
    };
  });
  // const client = new DynamoDBClient({ region });
  // const input = {
  //   RequestItems: {
  //     [TABLE_NAME]: newCVEs
  //   }
  // };
  //const command = new BatchWriteItemCommand(input);
  //const response = await client.send(command);
  //return Promise.resolve(response);
  return Promise.resolve();
}

async function getFreshCVEs({
  apiKey,
  endpoint,
  periodDays,
  resultsPerPage,
  throttleTimeout
}) {
  const formatDate = (date) =>
    date.toISOString().replace(/(:\d{2})(\.)(\d{3,})(Z)/gm, '$1:$3 UTC');
  const end = new Date();
  let start = new Date();
  start.setDate(end.getDate() - periodDays);
  let startIndex = 0;
  let totalResults = Number.POSITIVE_INFINITY;
  let CVEList = [];
  do {
    const URL = `${endpoint}?apiKey=${apiKey}&resultsPerPage=${resultsPerPage}&modStartDate=${formatDate(
      start
    )}&modEndDate=${formatDate(end)}&startIndex=${startIndex}`;
    let isError = false;
    const responseData = await fetch(URL)
      .catch((error) => {
        isError = error;
      })
      .then((response = {}) => {
        const {
          ok,
          status = 'Unknown',
          statusText = 'Request failed'
        } = response;
        if (!ok) {
          isError = new Error(status + statusText);
        }
        return response.json ? response.json() : { ok, status, statusText };
      });
    if (isError) {
      console.log(isError);
      break;
    }
    totalResults = responseData.totalResults || 0;
    const { result: { CVE_Items = [] } = {} } = responseData;
    CVEList = [...CVEList, ...CVE_Items];
    startIndex += parseInt(resultsPerPage);
    // adding throttle timeouts to avoid rejected requests
    await new Promise((resolve) =>
      setTimeout(() => resolve(), parseInt(throttleTimeout))
    );
  } while (startIndex < totalResults);
  return CVEList;
}

async function getNVDParams({ region }) {
  const secretName = '/ThreatTools/Integrations/nvd';
  const client = new AWS.SecretsManager({
    region
  });
  return new Promise((resolve) => {
    client.getSecretValue({ SecretId: secretName }, function(err, data) {
      if (err) {
        if (err.code === 'DecryptionFailureException') {
          throw err;
        } else if (err.code === 'InternalServiceErrorException') {
          throw err;
        } else if (err.code === 'InvalidParameterException') {
          throw err;
        } else if (err.code === 'InvalidRequestException') {
          throw err;
        } else if (err.code === 'ResourceNotFoundException') {
          throw err;
        }
        resolve(err);
      } else {
        if ('SecretString' in data) {
          resolve(JSON.parse(data.SecretString));
        } else {
          let buff = new Buffer(data.SecretBinary, 'base64');
          resolve(buff.toString('ascii'));
        }
      }
    });
  });
}

async function createCVETableIfNotExist({ region }) {
  var dynamodb = new AWS.DynamoDB({ region, maxRetries: 3, sslEnabled: true });
  const tableNotExist = await new Promise((resolve) => {
    dynamodb.describeTable(
      {
        TableName: TABLE_NAME
      },
      function(err = {}, data) {
        if (err) {
          if (err.code === 'ResourceNotFoundException') {
            // table does not exist
            resolve(true);
          } else {
            console.log('Unable to create table', JSON.stringify(err));
          }
        } else {
          resolve(false);
        }
      }
    );
  });
  return new Promise((resolve) => {
    if (tableNotExist) {
      dynamodb.createTable(TABLE_DEFINITION, function(err, data) {
        if (err) {
          console.log('Unable to create table', JSON.stringify(err));
          resolve(false);
        } else {
          resolve(true);
        }
      });
    } else {
      resolve(true);
    }
  });
}

// async function getAccountId () {
//   const sts = new AWS.STS();
//   const { Account: account } = await sts.getCallerIdentity({}).promise();
//   return account;
// }
exports.handler = handler;

handler();
