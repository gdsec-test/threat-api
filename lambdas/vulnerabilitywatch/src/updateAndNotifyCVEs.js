const fetch = (...args) =>
  import('node-fetch').then(({ default: fetch }) => fetch(...args));
const getCVEScore = require('./getCVEScore');
const saveCVE = require('./saveCVE');

module.exports = function updateAndNotifyCVEs({
  freshCVEs,
  CVEsFromDB,
  dynamodb,
  params
}) {
  const { periodDays, slackWebhook, cveCatalogURL } = params;
  const updatedCVEs = [];
  const newCVEs = [];
  for (var [ID, freshCVE] of freshCVEs) {
    const newScore = getCVEScore(freshCVE);
    if (CVEsFromDB.has(ID)) {
      // DB contains existing CVE
      const dbCVEScore = CVEsFromDB.get(ID);
      if (dbCVEScore.toString() !== newScore.toString()) {
        // shoot slack message and update CVE
        updatedCVEs.push({ ID, oldScore: dbCVEScore, newScore });
        saveCVE({ item: freshCVE, dynamodb }); // CVE is present, but it needs to be updated in DB
      }
    } else {
      newCVEs.push({ ID, score: newScore });
      saveCVE({ item: freshCVE, dynamodb }); // CVE is new and needs to be saved in DB
    }
  }
  if (updatedCVEs.length || newCVEs.length) {
    fetch(slackWebhook, {
      method: 'post',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        thread_ts: 'PARENT_MESSAGE_TS',
        text:
          `The next CVEs have changed their score in last ${periodDays} days\n` +
          updatedCVEs
            .map(
              ({ ID, oldScore, newScore }) =>
                `CVE: ${cveCatalogURL}${ID}: Score ${oldScore} -> ${newScore}`
            )
            .join('\n') +
          `\nThe next CVEs are new in last ${periodDays} days\n` +
          newCVEs
            .map(
              ({ ID, score }) => `CVE: ${cveCatalogURL}${ID}: Score ${score}`
            )
            .join('\n')
      })
    })
      .catch((err) => {
        console.log('Could not send alarm to Slack', err);
      })
      .then((data) => {
        console.log('Alarm sent to Slack', data);
      });
  }
};
