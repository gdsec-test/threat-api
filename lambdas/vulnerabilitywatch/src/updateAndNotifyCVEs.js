const fetch = (...args) =>
  import('node-fetch').then(({ default: fetch }) => fetch(...args));
const getCVEScore = require('./getCVEScore');
const saveCVE = require('./saveCVE');
const Logger = require('./logger');
module.exports = async function updateAndNotifyCVEs({
  freshCVEs,
  CVEsFromDB,
  dynamodb,
  params
}) {
  const { periodDays, slackWebhook, cveCatalogURL } = params;
  const updatedCVEs = [];
  const newCVEs = [];
  Logger.log('Start of update and notify CVEs');
  for (var [ID, freshCVE] of freshCVEs) {
    const newScore = getCVEScore(freshCVE);
    if (CVEsFromDB.has(ID)) {
      // DB contains existing CVE
      const dbCVEScore = CVEsFromDB.get(ID);
      if (dbCVEScore.toString() !== newScore.toString()) {
        // shoot slack message and update CVE
        updatedCVEs.push({ ID, oldScore: dbCVEScore, newScore });
        saveCVE({ item: freshCVE, dynamodb }); // CVE is present, but it needs to be updated in DB
      }
    } else {
      newCVEs.push({ ID, score: newScore });
      saveCVE({ item: freshCVE, dynamodb }); // CVE is new and needs to be saved in DB
    }
  }
  Logger.log('Calling Slack to send notification');
  return fetch(slackWebhook, {
    method: 'post',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      thread_ts: 'PARENT_MESSAGE_TS',
      text:
        `The next CVEs have changed their score in last ${periodDays} days\n` +
        updatedCVEs
          .map(
            ({ ID, oldScore, newScore }) =>
              `<${cveCatalogURL}${ID}|${ID}>:${oldScore} -> ${newScore}`
          )
          .join(', ') +
        `\nThe next CVEs are new in last ${periodDays} days\n` +
        newCVEs
          .map(({ ID, score }) => `<${cveCatalogURL}${ID}|${ID}>:${score}`)
          .join(', ')
    })
  })
    .catch((err) => {
      Logger.log('Could not send alarm to Slack' + JSON.stringify(err));
    })
    .then((data) => {
      Logger.log('Alarm sent to Slack' + JSON.stringify(data));
    });
};
