const fetch = (...args) =>
  import('node-fetch').then(({ default: fetch }) => fetch(...args));

const Logger = require('../logger');
const getCPEData = require('../utils/getCPEData');

const BLOCKS_PER_MESSAGE = 50;
const MAX_TEXT_SIZE = 3000;
const clampIt = (str) => str.slice(0, MAX_TEXT_SIZE);

const getCVEFormattedRecord = (
  { ID, oldScore, score, data },
  { cveCatalogURL }
) => {
  const {
    cve: {
      problemtype: { problemtype_data = [] } = {},
      description: { description_data = [] } = {}
    }
  } = data;

  const scoreDesc = oldScore
    ? `${oldScore} -> ${score}(updated)`
    : `${score}(new)`;
  const CWEsFound = problemtype_data.reduce((acc, { description = [] }) => {
    acc += description
      .map(({ value }) => `<https://www.google.com/search?q=${value}|${value}>`)
      .join(' ');
    acc += ' ';
    return acc;
  }, '');
  const description = description_data.map(({ value }) => `${value}`).join(' ');
  const CPEData = '\n:red-flag:' + getCPEData(data).join('\n:red-flag:');
  return [
    {
      type: 'context',
      elements: [
        {
          type: 'mrkdwn',
          text: clampIt(
            `:warning:  *CVE*: <${cveCatalogURL}${ID}|${ID}> *Score*:${scoreDesc}\n*Description*: ${description}\n` +
              `*CPEs*: ${CPEData}\n*CWE*: ${CWEsFound}`
          )
        }
      ]
    },
    {
      type: 'actions',
      elements: [
        {
          type: 'button',
          style: 'primary',
          action_id: 'create_incident_in_snow',
          text: {
            type: 'plain_text',
            text: `Create Incident for ${ID}`
          },
          url: 'https://godaddy.service-now.com/nav_to.do?uri=%2Fincident.do%3Fsys_id%3D-1'
        }
      ]
    },
    {
      type: 'divider'
    }
  ];
};

module.exports = async function slack({
  periodDays,
  updatedCVEs,
  newCVEs,
  cveCatalogURL,
  cvssRange = [],
  creds: { botToken, channel } = {}
}) {
  async function sendSlackMessage({ blocks, parentThread = '' }) {
    return await fetch('https://slack.com/api/chat.postMessage', {
      method: 'post',
      headers: {
        'Content-Type': 'application/json; charset=utf-8',
        Authorization: `Bearer ${botToken}`
      },
      body: JSON.stringify({
        username: 'Threat Vulnerability Alert',
        channel: `${channel}`,
        thread_ts: parentThread,
        blocks
      })
    })
      .then((response) => {
        return response.json();
      })
      .then((data = {}) => {
        if (data.ok) {
          Logger.log('Alarm sent to Slack successfully');
        } else {
          Logger.log('Alarm sent to Slack with errors' + JSON.stringify(data));
        }
        return data;
      })
      .catch((err = {}) => {
        Logger.log('Could not send alarm to Slack' + JSON.stringify(err));
      });
  }
  const updatedCVEsFormatted = updatedCVEs.reduce((acc, cve) => {
    acc = [...acc, ...getCVEFormattedRecord(cve, { cveCatalogURL })];
    return acc;
  }, []);
  const newCVEsFormatted = newCVEs.reduce((acc, cve) => {
    acc = [...acc, ...getCVEFormattedRecord(cve, { cveCatalogURL })];
    return acc;
  }, []);
  const { ts: parentThreatId } = await sendSlackMessage({
    blocks: [
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text:
            `Report for CVEs with scores ${cvssRange[0]} to ${cvssRange[1]} in the last ${periodDays} days\n` +
            `*New*: ${newCVEsFormatted.length}, *Updated* :${updatedCVEsFormatted.length}`
        }
      }
    ]
  });
  const blocks = [
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `*UPDATED CVEs*`
      }
    },
    {
      type: 'divider'
    },
    ...updatedCVEsFormatted,
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `*NEW CVEs*`
      }
    },
    {
      type: 'divider'
    },
    ...newCVEsFormatted
  ];

  const splitBlocks = [];
  while (blocks.length) {
    splitBlocks.push(blocks.splice(0, BLOCKS_PER_MESSAGE));
  }
  const result = await Promise.all(
    splitBlocks.map((smallerBlock) => {
      return sendSlackMessage({
        parentThread: parentThreatId,
        blocks: smallerBlock
      });
    })
  );
  return result;
};
